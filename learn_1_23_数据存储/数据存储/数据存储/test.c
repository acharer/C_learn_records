#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>

int main()
{
	int a = 20;
	//00000000000000000000000000010100 - 原
	//0x00 00 00 14
	//00000000000000000000000000010100 - 反
	//00000000000000000000000000010100 - 补

	int b = -10;
	//10000000000000000000000000001010 - 原
	//11111111111111111111111111110101 - 反
	//11111111111111111111111111110110 - 补

	printf("%08x\n", a);
	printf("%08x\n", b);

	//在计算机系统中，数值一律用补码来表示和存储，原因在于，使用补码，可以将
	//符号位和数值域统一处理
	//同时，加法和减法也可以统一处理(CPU只有加法器)此外，补码和源码相互转换，
	//其运算过程是相同的，不需要额外的硬件电路

	//例如计算减法1-1
	//计算机其实就是把 1(补码)+(-1)(补码)




	//大端字节序
	//高位字节存放在低地址，低位字节存放在高地址
	//小端字节序
	//低位字节存放在低地址，高位字节存放在高地址

	//有符号char
	//-128~127
	//10000000会被直接解析为-128
	//无符号char
	//0~255
	//有符号short -32768~32767
	//无符号short 0~65535
	
	char e = -1;
	signed char f = -1;
	unsigned char g = -1;

	printf("e=%d,f=%d,g=%d\n", e, f, g);

	char a2 = -128;
	//10000000000000000000000010000000 - 原
	//11111111111111111111111101111111 - 反
	//11111111111111111111111110000000 - 补
	//10000000 - 截断放进a2
	//11111111111111111111111110000000 - 整形提升
	printf("a2=%u\n", a2);//把a2当成无符号数打印，无需再转换成原码
	printf("a2=%d\n", a2);//把a2当成有符号数打印，需要转换成原码

	//char类型的范围是-128~127
	char a3 = 128;
	//10000000000000000000000010000000 - 原
	//10000000 - 截断放进a3
	//11111111111111111111111110000000 - 整形提升
	//10000000000000000000000010000000 - 转换成原码
	printf("a3 = %u\n", a3);//把a3当成无符号数打印，无需再转换成原码
	printf("a3 = %d\n", a3);//把a3当成有符号数打印，需再转换成原码

	int i = -20;
	//10000000000000000000000000010100
	//11111111111111111111111111101011
	//11111111111111111111111111101100 - -20的补码
	unsigned int j = 10;
	//00000000000000000000000000001010 - 10的补码
	//11111111111111111111111111110110 - i+j的补码
	//10000000000000000000000000001001
	//10000000000000000000000000001010 - i+j的原码 i+j=-10
	printf("i+j=%d\n", i + j);
	printf("i+j=%u\n", i + j);

	return 0;
}