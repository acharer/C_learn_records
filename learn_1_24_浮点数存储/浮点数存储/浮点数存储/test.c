#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>

int main()
{
	int n = 9;
	float* pFloat = (float*)&n;

	printf("n的值为：%d\n", n);
	printf("*pFloat的值为：%f\n", *pFloat);

	*pFloat = 9.0;
	printf("n的值为：%d\n", n);
	printf("*pFloat的值为：%f\n", *pFloat);


	//国际标准IEEE规定，任意一个二进制浮点数V可以表示成下面的形式：
	// V = (-1)^S * M * 2^E
	// (-1)^S表示符号位，当S=0,V为正数当S=1，V为负数
	// M表示有效数字，大于等于1，小于2
	// 2^E表示指数位
	//
	// 例如：
	//		V = 5.0f;	二进制表示101.0  ---> 1.01 * 2^2
	//        = 1.01 * 2^2
	//		  = (-1)^0 * 1.01 * 2^2
	//		这里 S=0 M=1.01 E=2
	//		V = 9.5f；	二进制表示1001.1(请看浮点数的二进制表示.png)
	//		  = 1001.1  
	//		  = 1.0011 * 2^3
	//		  = (-1)^0 * 1.0011 * 2^3
	//		这里 S=0 M=1.0011 E=3
	//有的数是无法二进制精确表示的，因此浮点数在内存中也不一定能够精确保存
	//如：V=9.6f   1001.10000101101010......小数点后面无论是什么，都难以精确表示0.6
	//浮点数在内存中存储的就是S M E，详情请看同目录下的 浮点数在内存中的存储.png
	//其中M总能写成 1.xxxxxx 的形式，因此在存储M的时候，默认M的第一位总是1，因此
	//可以被舍去，只保存后面的xxxxxx部分，读取时再把1加上去

	//而在存储E的时候，规定存储的E是无符号的，但是实际上E可能是个负数
	//因此在存储E的时候，存的是 E(真实值)+ 中间值(float为127，double为1023)，
	//来保证E是个正数

	unsigned char num1 = 9;
	float* pnum1 = (float*)&num1;

	*pnum1 = 9.0;
	printf("num1 = %d\n", num1);

	return 0;
}